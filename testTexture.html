<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Three.js performance test</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #000; font-family:Monospace; font-size:13px; text-align:center;
                font-weight: bold; background-color: #fff; margin: 0px; overflow: hidden;
            }
            #info { color:#000; position: absolute; top: 0px; width: 100%; padding: 5px; }
            a { color: red; }
        </style>
    </head>

    <body>
        <div id="container"></div>
        <div id="info">
            <a href="http://threejs.org" target="_blank">three.js</a> - trackball controls example</br>
            MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
        </div>
        <script src="js/three.min.js"></script>
        <script src="js/controls/TrackballControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src="three-texts.js"></script>
        <script>
            if (!Detector.webgl)
                Detector.addGetWebGLMessage();

            var container, stats;
            var width = 180;
            var height = 90;
            var objs = new Array();
            var lastTime;
            var camera, controls, scene, renderer;
            var cross;
            var shipsGeo;

            init();
            animate();

            function init() {
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
//				camera = new THREE.OrthographicCamera();
                camera.position.z = 50;
                controls = new THREE.TrackballControls(camera);
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.keys = [65, 83, 68];
                controls.addEventListener('change', render);

                // world
                scene = new THREE.Scene();
                scene.add(new THREE.Mesh(new THREE.PlaneGeometry(width, height),
                        new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('textures/map.jpeg')})));

                var fontSize = 16;
                var lettersPerSide = 16;
                var charMaterial = createCharMaterial(lettersPerSide, fontSize);
                var shipGeom = new THREE.PlaneGeometry(1, 1);
                var shipMat = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('textures/spaceship.png'), transparent: true});
                shipsGeo = new THREE.Geometry();
                shipsGeo.dynamic = true;

                var num = 10000;
                for (var i = 0; i < num; i++) {
                    objs[i] = new Object();
                    mesh = new THREE.Mesh(shipGeom, shipMat);
                    objs[i].mesh = mesh;
                    objs[i].vx = (Math.random() - 0.5) * 1;
                    objs[i].vy = (Math.random() - 0.5) * 1;
                    mesh.position.x = (Math.random() - 0.5) * width;
                    mesh.position.y = (Math.random() - 0.5) * height;
                    mesh.position.z = i * 5.0 / num;//(Math.random()) * 5;
                    mesh.rotation.z = Math.atan2(objs[i].vy, objs[i].vx) + Math.PI / 2;
                    var x = mesh.position.x, y = mesh.position.y, z = mesh.position.z, a = mesh.rotation.z;
                    objs[i].id = i;
                    shipsGeo.vertices.push(
                            new THREE.Vector3(x, y, z),
                            new THREE.Vector3(x + 1 * Math.cos(a), y + 1 * Math.sin(a), z),
                            new THREE.Vector3(x + 1 * Math.cos(a) - 1 * Math.sin(a), y + 1 * Math.sin(a) + 1 * Math.cos(a), z),
                            new THREE.Vector3(x - 1 * Math.sin(a), y + 1 * Math.cos(a), z));
                    shipsGeo.faces.push(
                            new THREE.Face3(i * 4 + 0, i * 4 + 1, i * 4 + 2),
                            new THREE.Face3(i * 4 + 0, i * 4 + 2, i * 4 + 3));
                    shipsGeo.faceVertexUvs[0].push([
                        new THREE.Vector2(0, 0),
                        new THREE.Vector2(1, 0),
                        new THREE.Vector2(1, 1),
                    ], [
                        new THREE.Vector2(0, 0),
                        new THREE.Vector2(1, 1),
                        new THREE.Vector2(0, 1),
                    ]);


                    objs[i].text = new THREE.Mesh(textGeom("TRACK\n" + i, lettersPerSide, fontSize), charMaterial);
                    objs[i].text.position.x = objs[i].mesh.position.x;
                    objs[i].text.position.y = objs[i].mesh.position.y;
                    objs[i].text.position.z = objs[i].mesh.position.z + 0.01;
                    //                scene.add(objs[i].text);
                }
                scene.add(new THREE.Mesh(shipsGeo, shipMat));
                lastTime = new Date().getTime();
                renderer = new THREE.WebGLRenderer({antialias: false});
                renderer.setSize(window.innerWidth, window.innerHeight);
                container = document.getElementById('container');
                container.appendChild(renderer.domElement);
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = 100;
                container.appendChild(stats.domElement);
                window.addEventListener('resize', onWindowResize, false);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                controls.handleResize();
                render();
            }

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                var ct = new Date().getTime();
                var dt = (ct - lastTime) / 1000.0;
                lastTime = ct;
                for (i = 0; i < objs.length; i++) {
                    objs[i].mesh.position.x += objs[i].vx * dt;// + objs[i].ax * dt2;
                    objs[i].mesh.position.y += objs[i].vy * dt;// + objs[i].ay * dt2;
                    if (objs[i].mesh.position.x > width / 2) {
                        objs[i].mesh.position.x = width / 2;
                        objs[i].vx = -objs[i].vx;
                    } else if (objs[i].mesh.position.x < -width / 2) {
                        objs[i].mesh.position.x = -width / 2;
                        objs[i].vx = -objs[i].vx;
                    }
                    if (objs[i].mesh.position.y > height / 2) {
                        objs[i].mesh.position.y = height / 2;
                        objs[i].vy = -objs[i].vy;
                    } else if (objs[i].mesh.position.y < -height / 2) {
                        objs[i].mesh.position.y = -height / 2;
                        objs[i].vy = -objs[i].vy;
                    }
                    objs[i].mesh.rotation.z = Math.atan2(objs[i].vy, objs[i].vx) + Math.PI / 2;
                    objs[i].text.position.x = objs[i].mesh.position.x;
                    objs[i].text.position.y = objs[i].mesh.position.y;
                    var x = objs[i].mesh.position.x, y = objs[i].mesh.position.y, z = objs[i].mesh.position.z, a = objs[i].mesh.rotation.z;

                    shipsGeo.vertices[i * 4 + 0].x = x;
                    shipsGeo.vertices[i * 4 + 0].y = y;
                    shipsGeo.vertices[i * 4 + 1].x = x + 1 * Math.cos(a);
                    shipsGeo.vertices[i * 4 + 1].y = y + 1 * Math.sin(a);
                    shipsGeo.vertices[i * 4 + 2].x = x + 1 * Math.cos(a) - 1 * Math.sin(a);
                    shipsGeo.vertices[i * 4 + 2].y = y + 1 * Math.sin(a) + 1 * Math.cos(a);
                    shipsGeo.vertices[i * 4 + 3].x = x - 1 * Math.sin(a);
                    shipsGeo.vertices[i * 4 + 3].y = y + 1 * Math.cos(a);
                }
                shipsGeo.verticesNeedUpdate = true;
                render();
            }

            function render() {
                renderer.render(scene, camera);
                stats.update();
            }
        </script>
    </body>
</html>		