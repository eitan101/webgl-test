<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Three.js performance test</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #000; font-family:Monospace; font-size:13px; text-align:center;
                font-weight: bold; background-color: #fff; margin: 0px; overflow: hidden;
            }
            #info { color:#000; position: absolute; top: 0px; width: 100%; padding: 5px; }
            a { color: red; }
        </style>
    </head>
    <!-- Shaders -->
    <script type="x-shader/x-vertex" id="vertexshader">		
        attribute vec2 vel;
        attribute float ts;
        uniform float clk;

        varying mat2 RotationMatrix;
        void main() {
            float PI = 3.14159265358979323846264;
            vec3 newPosition = position+(clk-ts)*vec3(vel,0);
            vec4 mvPosition = modelViewMatrix * vec4( newPosition, 1.0 );
            gl_PointSize = 4.0 * ( 300.0 / length( mvPosition.xyz ) );
            gl_Position = projectionMatrix * mvPosition;
            float Angle = atan(vel.y,vel.x)-PI/2.0;
            RotationMatrix = mat2( cos( Angle ), -sin( Angle ), sin( Angle ),  cos( Angle ));
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D texture1;
        varying mat2 RotationMatrix;

        void main() {
            vec2 v = (gl_PointCoord-vec2(0.5,0.5))*RotationMatrix+vec2(0.5,0.5);
            if (v.x<0.0 || v.x>1.0 || v.y<0.0 || v.y>1.0)
                discard;
            gl_FragColor = texture2D( texture1, v );
        }	
    </script>
    <body>
        <div id="container"></div>
        <div id="info">
            <a href="http://threejs.org" target="_blank">three.js</a> - trackball controls example</br>
            MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
        </div>
        <script src="js/three.min.js"></script>
        <script src="js/controls/TrackballControls.js"></script>
        <script src="js/controls/FlyControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/libs/tween.min.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src="three-texts.js"></script>
        <script src="js/d3.v3.min.js" charset="utf-8"></script>
        <script>
if (!Detector.webgl)
    Detector.addGetWebGLMessage();

var container, stats;
var width = 1000;
var height = width / 2;
var objs = new Array();
var lastclk;
var camera, controls, scene, renderer;
var cross;
var shipsGeo;
var attributes = {
    vel: {type: 'v2', value: []},
//    acc: {type: 'v2', value: []},
    ts: {type: 'f', value: []}
};
var shipMesh;
var uniforms = {
    clk: {type: 'f', value: []},
    texture1: {type: "t", value: THREE.ImageUtils.loadTexture('textures/spaceship.png')}
};
var num = 200000;
var text2;
var selected = -1;
var projection = d3.geo.equirectangular()
        .scale((width + 1) / 2 / Math.PI)
        .translate([0, 0])
        .precision(.1);

init();
//animate();

function init() {
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    var carpos = projection([35.213722, 31.768379]);
    camera.position.z = 200.0;

    controls = new THREE.TrackballControls(camera);
    controls.rotateSpeed = 1.0;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 1.8;
    controls.noZoom = false;
    controls.noPan = false;
    controls.noRotate = true;

    controls.staticMoving = true;
    controls.dynamicDampingFactor = 0.3;
    controls.keys = [65, 83, 68];
    controls.addEventListener('change', render);

    // world
    scene = new THREE.Scene();
    scene.add(new THREE.Mesh(new THREE.PlaneGeometry(width, height),
            new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('textures/world.png')})));

    // create the sphere's material
    var shaderMaterial = new THREE.ShaderMaterial({
        uniforms: uniforms,
        attributes: attributes,
        transparent: true,
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent
    });

    var fontSize = 16;
    var lettersPerSide = 16;
    var charMaterial = createCharMaterial(lettersPerSide, fontSize);
    var shipGeom = new THREE.PlaneGeometry(1, 1);
    var shipMat = new THREE.MeshBasicMaterial({map: THREE.ImageUtils.loadTexture('textures/spaceship.png'), transparent: true});
    shipsGeo = new THREE.Geometry();
    shipsGeo.dynamic = true;

    var maxheight = 20.0;
    for (var i = 0; i < num; i++) {
        objs[i] = new Object();
        objs[i].z = i * maxheight / num;
        shipsGeo.vertices.push(new THREE.Vector3());
        attributes.vel.value.push(new THREE.Vector2());
        attributes.ts.value.push(0);
    }

    shipMesh = new THREE.ParticleSystem(shipsGeo, shaderMaterial);
    scene.add(shipMesh);
    lastclk = new Date().getTime();
    renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    container = document.getElementById('container');
    container.appendChild(renderer.domElement);
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.bottom = '0px';
    stats.domElement.style.zIndex = 100;
    container.appendChild(stats.domElement);
    container.addEventListener('mousedown', onMouseMove, false);

    window.addEventListener('resize', onWindowResize, false);

    text2 = document.createElement('div');
    text2.style.position = 'absolute';
    //text2.style.zIndex = 1;
    text2.style.width = 200;
    text2.style.height = 120;
    text2.style.backgroundColor = "#696969";
    text2.style.color = "white";
    text2.style.opacity = 0.5;
    text2.innerHTML = "hi there!";
    text2.style.top = 10 + 'px';
    text2.style.left = 10 + 'px';
    document.body.appendChild(text2);
}

function randomAllShips(ct) {
    var size = 1;    
    for (var i = 0; i < num; i++) {
        objs[i].vx = (Math.random() - 0.5) * size;
        objs[i].vy = (Math.random() - 0.5) * size;
        var cart = projection([(Math.random() - 0.5) * 360, -(Math.random() - 0.5) * 180]);
        objs[i].x = cart[0];
        objs[i].y = cart[1];
        objs[i].id = i;
        objs[i].ts = ct;
        updateShip(objs[i],shipsGeo,attributes);
    }
    shipsGeo.verticesNeedUpdate = true;    
    attributes.vel.needsUpdate = true;
    attributes.ts.needsUpdate = true;
}

function updateAllShips(ct) {
    for (var i = 0; i < num; i++) {
        var dt = ct - objs[i].ts;
        objs[i].x += objs[i].vx * dt;
        objs[i].y += objs[i].vy * dt;
        objs[i].ts = ct;
        updateShip(objs[i],shipsGeo,attributes);
    }
    shipsGeo.verticesNeedUpdate = true;    
    //attributes.vel.needsUpdate = true;
    attributes.ts.needsUpdate = true;
}

function updateShip(ship,shipsGeo,attributes) {
    var vertex = shipsGeo.vertices[ship.id]
    vertex.x = ship.x;
    vertex.y = ship.y;
    vertex.z = ship.z;
    var attrib = attributes.vel.value[ship.id];
    attrib.x = ship.vx;
    attrib.y = ship.vy;
    attributes.ts.value[ship.id] = ship.ts;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    controls.handleResize();
    render();
}

function onMouseMove(event) {


    var mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    var mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

    var vector = new THREE.Vector3(mouseX, mouseY, camera.near);

    // Convert the [-1, 1] screen coordinate into a world coordinate on the near plane
    var projector = new THREE.Projector();
    projector.unprojectVector(vector, camera);

    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

    // See if the ray from the camera into the world hits one of our meshes
    var intersects = raycaster.intersectObject(shipMesh);
    lastIntersects = intersects;

    // Toggle rotation bool for meshes that we clicked
    if (intersects.length > 0) {
        //					   text2.innerHTML = "Track selected: "+Math.floor(intersects[ 0 ].faceIndex / 2);
        selected = Math.floor(intersects[ 0 ].faceIndex / 2);

        new TWEEN.Tween(camera.position).to({
            x: intersects[ 0 ].point.x,
            y: intersects[ 0 ].point.y,
            z: camera.position.z}
        , 500).easing(TWEEN.Easing.Cubic.InOut).start();


        update_text();
        console.log(intersects[ 0 ]);
    } else {
        selected = -1;
        update_text();
    }
}

function update_text() {
    if (selected >= 0) {
        text2.innerHTML = "Track selected: " + selected + "<br/>" +
                "geo: " + projection.invert([objs[selected].x, -objs[selected].y]);
    } else
        text2.innerHTML = "Track selected: none<br/><br/>";
}

var lastUpdate = 0;
uniforms.clk.value = 0;
var lastTimeMsec= null
requestAnimationFrame(function animate(nowMsec){
    // keep looping
    requestAnimationFrame( animate );
    // measure time
    lastTimeMsec    = lastTimeMsec || nowMsec-1000/60
    var deltaMsec   = Math.min(200, nowMsec - lastTimeMsec)
    lastTimeMsec    = nowMsec
    // call each update function
    controls.update();

//    var ct = new Date().getTime();
    uniforms.clk.value += deltaMsec*0.001;
    var dt = (nowMsec - lastUpdate) / 1000.0;
    if (dt>0.5) {
        if (lastUpdate==0)
            randomAllShips(uniforms.clk.value);
        else
            updateAllShips(uniforms.clk.value);
        lastUpdate = nowMsec;
    }
    render();
})
 
// randomAllShips(uniforms.clk.value);
 
// setInterval(function(){
//     alert("Hello")
// },3000);

function render() {
    TWEEN.update();
    renderer.render(scene, camera);
    stats.update();
}
        </script>
    </body>
</html>		