<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - trackball controls</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #000;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;

                background-color: #fff;
                margin: 0px;
                overflow: hidden;
            }

            #info {
                color:#000;
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;

            }

            a {
                color: red;
            }
        </style>
    </head>

    <body>
        <div id="container"></div>
        <div id="info">
            <a href="http://threejs.org" target="_blank">three.js</a> - trackball controls example</br>
            MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
        </div>

        <script src="js/three.min.js"></script>

        <script src="js/controls/TrackballControls.js"></script>

        <script src="js/Detector.js"></script>
        <script src="js/libs/stats.min.js"></script>

        <script>
            if (!Detector.webgl)
                Detector.addGetWebGLMessage();

            var container, stats;
            var width = 180;
            var height = 90;
            var objs = new Array();
            var lastTime;

            var camera, controls, scene, renderer;

            var cross;

            init();
            animate();
//			var d = new Date();

            function createCharMaterial(lettersPerSide, fontSize) {
                var c = document.createElement('canvas');
                c.width = c.height = fontSize * lettersPerSide;
                var ctx = c.getContext('2d');
                ctx.font = fontSize + 'px Monospace';
                var i = 0;

                for (var y = 0; y < lettersPerSide; y++) {
                    for (var x = 0; x < lettersPerSide; x++, i++) {
                        var ch = String.fromCharCode(i);
                        ctx.fillText(ch, x * fontSize, -(8 / 32) * fontSize + (y + 1) * fontSize);
                    }
                }
                var tex = new THREE.Texture(c);
                tex.needsUpdate = true;

                var mat = new THREE.MeshBasicMaterial({map: tex});
                mat.transparent = true;
                return mat;
            }

            function textGeom(str, lettersPerSide, fontSize) {
                var geo = new THREE.Geometry();
                //var str = "hello12";

                var j = 0, ln = 0;

                for (i = 0; i < str.length; i++) {
                    var code = str.charCodeAt(i);
                    var cx = code % lettersPerSide;
                    var cy = Math.floor((256 - code) / lettersPerSide);
                    var v, t;
                    var p = 4 / 16;
                    geo.vertices.push(
                            new THREE.Vector3(p * (j * 1.1 + 0.05), p * (ln * 1.1 + 0.05), 0),
                            new THREE.Vector3(p * (j * 1.1 + 1.05), p * (ln * 1.1 + 0.05), 0),
                            new THREE.Vector3(p * (j * 1.1 + 1.05), p * (ln * 1.1 + 1.05), 0),
                            new THREE.Vector3(p * (j * 1.1 + 0.05), p * (ln * 1.1 + 1.05), 0)
                            );
                    geo.faces.push(new THREE.Face3(i * 4 + 0, i * 4 + 1, i * 4 + 2));
                    geo.faces.push(new THREE.Face3(i * 4 + 0, i * 4 + 2, i * 4 + 3));

                    var ox = cx / lettersPerSide, oy = cy / lettersPerSide, off = 1 / lettersPerSide;
                    var sz = lettersPerSide * fontSize;
                    geo.faceVertexUvs[0].push([
                        new THREE.Vector2(ox, oy),
                        new THREE.Vector2(ox, oy + off),
                        new THREE.Vector2(ox + off, oy + off),
                    ]);
                    geo.faceVertexUvs[0].push([
                        new THREE.Vector2(ox, oy),
                        new THREE.Vector2(ox + off, oy + off),
                        new THREE.Vector2(ox + off, oy),
                    ]);
                    if (code == 10) {
                        ln--;
                        j = 0;
                    } else {
                        j++;
                    }
                }
                return geo;

            }


            function init() {
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);

//				camera = new THREE.OrthographicCamera();
                camera.position.z = 50;

                controls = new THREE.TrackballControls(camera);

                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;

                controls.noZoom = false;
                controls.noPan = false;

                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;

                controls.keys = [65, 83, 68];

                controls.addEventListener('change', render);

                // world

                scene = new THREE.Scene();
//				scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

                var shipGeom = new THREE.PlaneGeometry(width, height);
                var texture = THREE.ImageUtils.loadTexture('textures/kk.jpeg');
//				texture.anisotropy = renderer.getMaxAnisotropy();

                var shipMat = new THREE.MeshBasicMaterial({map: texture});


                var mesh = new THREE.Mesh(shipGeom, shipMat);
                scene.add(mesh);




                var fontSize = 16;
                var lettersPerSide = 16;

                var charMaterial = createCharMaterial(lettersPerSide, fontSize);

                texture = THREE.ImageUtils.loadTexture('textures/spaceship.png');

                shipGeom = new THREE.PlaneGeometry(1, 1);
                shipMat = new THREE.MeshBasicMaterial({map: texture});
                shipMat.transparent = true;

                for (var i = 0; i < 5000; i++) {

                    objs[i] = new Object();
                    mesh = new THREE.Mesh(shipGeom, shipMat);
                    objs[i].mesh = mesh;
                    objs[i].x = (Math.random() - 0.5) * width;
                    objs[i].y = (Math.random() - 0.5) * height;
                    objs[i].vx = (Math.random() - 0.5) * 0.5;
                    objs[i].vy = (Math.random() - 0.5) * 0.5;
                    mesh.position.x = objs[i].x;
                    mesh.position.y = objs[i].y;
                    mesh.position.z = (Math.random()) * 5;
                    mesh.rotation.z = Math.atan2(objs[i].vy, objs[i].vx) + Math.PI / 2;
                    objs[i].id = i;
                    scene.add(mesh);
                    objs[i].text = new THREE.Mesh(textGeom("s" + i, lettersPerSide, fontSize), charMaterial);
                    objs[i].text.position.x = objs[i].mesh.position.x;
                    objs[i].text.position.y = objs[i].mesh.position.y;
                    objs[i].text.position.z = objs[i].mesh.position.z + 0.01;
                    scene.add(objs[i].text);

                }
                lastTime = new Date().getTime();

                // create a canvas element


                // lights
                /*
                 light = new THREE.DirectionalLight( 0xffffff );
                 light.position.set( 1, 1, 1 );
                 scene.add( light );
                         
                 light = new THREE.DirectionalLight( 0x002288 );
                 light.position.set( -1, -1, -1 );
                 scene.add( light );
                         
                 light = new THREE.AmbientLight( 0x222222 );
                 scene.add( light );
                 */

                // renderer

                // renderer = new THREE.WebGLRenderer( { antialias: false } );
                renderer = new THREE.WebGLRenderer({antialias: false});
//				renderer.setClearColor( scene.fog.color, 1 );
                renderer.setSize(window.innerWidth, window.innerHeight);

                container = document.getElementById('container');
                container.appendChild(renderer.domElement);

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = 100;
                container.appendChild(stats.domElement);

                //

                window.addEventListener('resize', onWindowResize, false);

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

                controls.handleResize();

                render();

            }

            function animate() {

                requestAnimationFrame(animate);
                controls.update();
                var ct = new Date().getTime();
                var dt = (ct - lastTime) / 1000.0;
                lastTime = ct;
                for (i = 0; i < objs.length; i++) {
                    objs[i].mesh.position.x += objs[i].vx * dt;
                    objs[i].mesh.position.y += objs[i].vy * dt;
                    objs[i].needsUpdate = true;

                    if (objs[i].mesh.position.x > width / 2) {
                        objs[i].mesh.position.x = width / 2;
                        objs[i].vx = -objs[i].vx;
                        objs[i].mesh.rotation.z = Math.atan2(objs[i].vy, objs[i].vx) + Math.PI / 2;
                    } else if (objs[i].mesh.position.x < -width / 2) {
                        objs[i].mesh.position.x = -width / 2;
                        objs[i].vx = -objs[i].vx;
                        objs[i].mesh.rotation.z = Math.atan2(objs[i].vy, objs[i].vx) + Math.PI / 2;
                    }
                    if (objs[i].mesh.position.y > height / 2) {
                        objs[i].mesh.position.y = height / 2;
                        objs[i].vy = -objs[i].vy;
                        objs[i].mesh.rotation.z = Math.atan2(objs[i].vy, objs[i].vx) + Math.PI / 2;
                    } else if (objs[i].mesh.position.y < -height / 2) {
                        objs[i].mesh.position.y = -height / 2;
                        objs[i].vy = -objs[i].vy;
                        objs[i].mesh.rotation.z = Math.atan2(objs[i].vy, objs[i].vx) + Math.PI / 2;
                    }
                    objs[i].text.position.x = objs[i].mesh.position.x;
                    objs[i].text.position.y = objs[i].mesh.position.y;
                    objs[i].text.needsUpdate = true;

                }

                render();

            }

            function render() {

                renderer.render(scene, camera);
                stats.update();

            }


        </script>

    </body>
</html>
